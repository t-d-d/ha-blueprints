blueprint:
  name: Morning Brief on Alexa (LLM + Fallback + Retries)
  description: >
    On a single helper toggle (e.g., Alexa Routine "Alarm dismissed"),
    fetch today's Google Calendar events and weather, shape into a short briefing
    with an OpenAI Conversation agent (with retries/backoff), fall back to a
    simple formatter if needed, and speak it on selected Alexa device(s).
  domain: automation
  input:
    trigger_helper:
      name: Trigger helper (input_boolean exposed to Alexa)
      selector:
        entity:
          domain: input_boolean

    alexa_targets:
      name: Alexa device(s) to speak on
      description: One or more Echo devices from Alexa Media Player
      selector:
        entity:
          domain: media_player
          multiple: true

    calendars:
      name: Calendars to include
      selector:
        entity:
          domain: calendar
          multiple: true

    weather_entity:
      name: Weather entity
      selector:
        entity:
          domain: weather

    person_name:
      name: Person name (for personalization)
      default: ""
      selector:
        text:

    openai_agent:
      name: Conversation agent (OpenAI Conversation)
      description: Usually conversation.openai after adding the OpenAI Conversation integration
      default: conversation.openai
      selector:
        entity:
          domain: conversation

    speaking_style:
      name: Speaking style (prompt hint)
      default: "cheerful, concise, 20–30 seconds"
      selector:
        text:

    tts_mode:
      name: Alexa TTS mode
      description: "tts speaks immediately; announce plays a chime and can fan out"
      default: tts
      selector:
        select:
          options:
            - "tts"
            - "announce"

    max_events:
      name: Max events to include
      default: 12
      selector:
        number:
          min: 1
          max: 50
          step: 1
          mode: slider

    retry_attempts:
      name: LLM retry attempts
      description: Total tries (1 = no retry)
      default: 3
      selector:
        number:
          min: 1
          max: 5
          step: 1
          mode: slider

    retry_delay_ms:
      name: Base retry delay (ms)
      description: Exponential backoff uses base, base*2, base*4...
      default: 1200
      selector:
        number:
          min: 200
          max: 5000
          step: 100
          mode: slider

mode: single
max_exceeded: silent

variables:
  v_person: !input person_name
  v_style: !input speaking_style
  v_tts_mode: !input tts_mode
  v_max_events: !input max_events
  v_max_tries: !input retry_attempts
  v_base_delay_ms: !input retry_delay_ms

trigger:
  - platform: state
    entity_id: !input trigger_helper
    from: "off"
    to: "on"

action:
  # 0) Time windows: widen search (yesterday->tomorrow) then filter to today
  - variables:
      start_of_today: "{{ today_at('00:00:00') }}"
      end_of_today:   "{{ as_datetime(as_timestamp(today_at('00:00:00')) + 86400) }}"
      start_dt:       "{{ as_datetime(as_timestamp(start_of_today) - 86400) }}"  # yesterday 00:00
      end_dt:         "{{ as_datetime(as_timestamp(end_of_today) + 86400) }}"    # tomorrow 00:00
      start_today_ts: "{{ as_timestamp(start_of_today) }}"
      end_today_ts:   "{{ as_timestamp(end_of_today) }}"

  # 1) Pull events from selected calendars
  - service: calendar.get_events
    target:
      entity_id: !input calendars
    data:
      start_date_time: "{{ start_dt }}"
      end_date_time: "{{ end_dt }}"
    response_variable: agenda

  # 2) Pull today's weather forecast
  - service: weather.get_forecasts
    target:
      entity_id: !input weather_entity
    data:
      type: daily
    response_variable: forecast

  # 3) Extract today's forecast and flatten events that overlap today
  - variables:
      # Use the input entity id as key into the forecast mapping
      today_forecast: >-
        {% set key = !input weather_entity %}
        {% if forecast and key in forecast and 'forecast' in forecast[key] and (forecast[key]['forecast'] | count) > 0 %}
          {{ forecast[key]['forecast'][0] }}
        {% else %}{}{% endif %}

      events_flat_all: >-
        {% set items = [] %}
        {% for cal, payload in agenda.items() %}
          {% if payload is mapping and 'events' in payload and (payload['events'] | count) > 0 %}
            {% for e in payload['events'] %}
              {% set s = e['start'] %}
              {% set en = e['end'] %}
              {% set s_is_date = (s is string and s | length == 10) %}
              {% set e_is_date = (en is string and en | length == 10) %}
              {% set all_day = s_is_date and e_is_date %}
              {% set s_ts = as_timestamp(as_datetime(s)) %}
              {% set e_ts = as_timestamp(as_datetime(en)) %}
              {% set include = (s_ts < end_today_ts | float) and (e_ts > start_today_ts | float) %}
              {% if include %}
                {% set total_days = ((e_ts - s_ts) / 86400) | int %}
                {% set day_index = (((start_today_ts - s_ts) / 86400) | int) + 1 %}
                {% set items = items + [ {
                  'calendar': cal,
                  'summary': (e['summary'] if 'summary' in e else ''),
                  'description': (e['description'] if 'description' in e else ''),
                  'location': (e['location'] if 'location' in e else ''),
                  'start': s,
                  'end': en,
                  'start_ts': s_ts,
                  'end_ts': e_ts,
                  'all_day': all_day,
                  'multi_day': all_day and (total_days > 1),
                  'day_index': (day_index if all_day else 0),
                  'total_days': (total_days if all_day else 0)
                } ] %}
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        {{ items | sort(attribute='start_ts') }}

      events_flat: >-
        {% set items = events_flat_all %}
        {{ items[: (v_max_events | int)] }}

  # 4) Build the LLM prompt
  - variables:
      llm_prompt: >-
        You are generating a short morning briefing to be spoken by Alexa to {{ v_person }}.
        Use a friendly {{ v_style }} voice. Use British date/time conventions.
        Input data is JSON:
        {
          "date_iso": "{{ now().date().isoformat() }}",
          "events": {{ events_flat | tojson }},
          "weather_today": {{ today_forecast | tojson }}
        }
        Rules:
        - Start with weekday and date, then a one-line weather headline (temp highs/lows; mention rain chance if present).
        - List key events in chronological order with clear times (e.g., "at 08:30, GCSE Physics revision; at 11:00, dentist").
        - For all-day multi-day events, say "(day X of N)".
        - If there are no events, say that explicitly and give a brief encouragement.
        - Keep to about 3–6 short sentences. No markup; plain text only.

  # 5) LLM with retries + backoff
  - variables:
      speech_final: ""

  - repeat:
      until:
        - condition: template
          value_template: >-
            {{ (repeat.index >= (v_max_tries | int)) or ((speech_final | default('') | trim) != '') }}
      sequence:
        - service: conversation.process
          data:
            agent_id: !input openai_agent
            text: "{{ llm_prompt }}"
          response_variable: llm

        - variables:
            speech_try: >-
              {{ llm.response.speech.plain.speech
                 if llm is defined and llm.response is defined
                 and llm.response.speech is defined and llm.response.speech.plain is defined
                 else '' }}
            error_code: >-
              {% if llm is defined and llm.response is defined and llm.response.response_type == 'error' %}
              {{ llm.response.data.code | default('unknown') }}{% else %}{% endif %}
            error_msg: >-
              {% if llm is defined and llm.response is defined and llm.response.response_type == 'error' %}
              {{ llm.response.data.message | default('') }}{% else %}{% endif %}

        - choose:
            - conditions: "{{ speech_try | trim != '' }}"
              sequence:
                - variables:
                    speech_final: "{{ speech_try }}"
            - conditions: "{{ speech_try | trim == '' }}"
              sequence:
                - service: system_log.write
                  data:
                    level: warning
                    logger: "morning_brief.llm"
                    message: >-
                      LLM attempt {{ repeat.index }} failed{{ ' (' ~ error_code ~ ')' if error_code else '' }}.
                      {{ error_msg if error_msg else '' }}
                - delay:
                    milliseconds: >-
                      {{ (v_base_delay_ms | int) * (2 ** (repeat.index - 1)) }}

  # 6) Non-LLM fallback
  - variables:
      speech_basic: >-
        {% set parts = [] %}
        {% if today_forecast %}
          {% set cond = today_forecast.condition | default('') %}
          {% set hi = today_forecast.temperature | default('?') %}
          {% set lo = today_forecast.templow | default('?') %}
          {% set parts = parts + ['Morning ' ~ v_person ~ '. Today: ' ~ cond ~ ', high ' ~ hi ~ '°, low ' ~ lo ~ '°.'] %}
        {% endif %}
        {% if events_flat | count == 0 %}
          {% set parts = parts + ['No events in the calendar. Have a great day!'] %}
        {% else %}
          {% set parts = parts + ['Here are your events:'] %}
          {% for e in events_flat %}
            {% if e.all_day %}
              {% if e.multi_day and e.total_days > 1 %}
                {% set line = e.summary ~ ' (all day, day ' ~ e.day_index ~ ' of ' ~ e.total_days ~ ')' %}
              {% else %}
                {% set line = e.summary ~ ' (all day)' %}
              {% endif %}
            {% else %}
              {% set line = as_datetime(e.start).strftime('%H:%M') ~ ': ' ~ e.summary %}
            {% endif %}
            {% set parts = parts + [line] %}
          {% endfor %}
        {% endif %}
        {{ (parts | join(' '))[:790] }}

      speech: "{{ (speech_final | default('') | trim) if (speech_final | default('') | trim) != '' else speech_basic }}"

  # 7) DEBUG (safe). Remove later if you like.
  - variables:
      dbg_calendars: !input calendars
      dbg_agenda_json: "{{ agenda | tojson }}"
      dbg_events_json: "{{ events_flat | tojson }}"
      dbg_event_count: "{{ events_flat | count }}"
  - service: persistent_notification.create
    data:
      title: "Morning brief debug"
      message: >
        calendars_input = {{ dbg_calendars | tojson }}
        agenda_raw = {{ dbg_agenda_json }}
        events_today = {{ dbg_event_count }}
        first_event = {{ (events_flat[0] | tojson) if (events_flat | count) > 0 else 'none' }}

  # 8) Speak on Alexa (target INSIDE data)
  - service: notify.alexa_media
    data:
      target: !input alexa_targets
      message: "{{ speech[:790] }}"
      data:
        type: !input tts_mode

  # 9) Reset the helper
  - service: input_boolean.turn_off
    target:
      entity_id: !input trigger_helper
