blueprint:
  name: Alexa Alarm Brief
  description: >
    Speak a short morning brief on Alexa when an alarm rings (first ring) or after final dismiss.
    Works with sensor.*_next_alarm from Alexa Media Player (Echo) and Android HA Companion (phones).
    Optionally wait for Android Companion “Last Removed Notification” (dismiss) with timeout fallback.
    Optional weather; OpenAI Conversation formatting with retries + fallback; cooldown (under “Advanced”).
  domain: automation

  input:
    # --- Core (simple) ---
    alarm_sensors:
      name: Next-alarm sensors
      description: "Choose timestamp sensors like sensor.*_next_alarm from phones/Echos."
      selector:
        entity:
          multiple: true
          # If your entities don't show up, remove the filter block below.
          filter:
            - domain: sensor
              device_class: timestamp
              integration: mobile_app      # Android Companion app
            - domain: sensor
              device_class: timestamp
              integration: alexa_media     # Alexa Media Player

    # Optional: phone dismiss sensor (Companion App → Notification sensors → Last Removed Notification)
    dismiss_sensor:
      name: Phone 'Last Removed Notification' sensor (optional)
      description: "sensor.<phone>_last_removed_notification — used to speak after DISMISS; falls back if missing/timeout."
      default: ""
      selector:
        entity:
          domain: sensor

    first_ring_mode:
      name: Announce on first ring
      description: "On = speak at first ring (even if snoozed). Off = wait for final dismiss (heuristic)."
      default: false
      selector:
        boolean: {}

    alexa_targets:
      name: Alexa device(s) to speak on
      description: "Echo devices from Alexa Media Player."
      selector:
        entity:
          multiple: true
          # If your Echoes don't appear, remove the filter block below.
          filter:
            - domain: media_player
              integration: alexa_media

    calendars:
      name: Calendars to include
      selector:
        entity:
          domain: calendar
          multiple: true

    # Weather is optional: if set, a headline is included
    weather_entity:
      name: Weather entity (optional)
      default: ""
      selector:
        entity:
          domain: weather

    person_name:
      name: Person name (optional; leave blank to omit)
      default: ""
      selector:
        text: {}

    extra_instructions:
      name: Extra instructions (optional)
      description: "Additional prompt text the model should follow (tone, phrasing, constraints, etc.)"
      default: ""
      selector:
        text: {}

    exclude_other_mentions:
      name: Exclude events @'ed to others
      description: "On = include only untagged items, @<your name>, or @all"
      default: true
      selector:
        boolean: {}

    openai_agent:
      name: Conversation agent (OpenAI Conversation)
      description: "Usually conversation.openai"
      default: conversation.openai
      selector:
        entity:
          domain: conversation

    # --- Advanced (all optional; clear names, safe defaults) ---
    advanced:
      name: Advanced (optional)
      description: >
        Paste YAML or JSON with any of these fields (all optional; defaults shown):

        cooldown_minutes (int, default 3)
        snooze_window_minutes (int, default 20)           # ≤ this looks like a snooze
        pre_ring_grace_seconds (int, default 5)           # allow sensor flip up to 5s BEFORE alarm time
        after_ring_window_seconds (int, default 120)      # accept sensor updates this long AFTER alarm time
        no_dismiss_delay_seconds (int, default 30)        # if no dismiss, speak this long after alarm time
        dismiss_wait_timeout_seconds (int, default 60)    # wait up to this for 'Last Removed Notification'
        post_dismiss_delay_seconds (int, default 2)       # delay after a valid dismiss before speaking
        clock_app_package_regex (str, default "deskclock|clockpackage|oneplus.deskclock|android.deskclock")
        tts_mode (str: "tts" or "announce", default "tts")
        max_events (int, default 12)
        retry_attempts (int, default 3)
        retry_base_delay_ms (int, default 1200)

        # Debug switches (for isolating crashes/restarts)
        debug_disable_tts (bool, default false)           # when true, skip Alexa TTS step
        debug_disable_llm (bool, default false)           # when true, skip LLM call (use fallback speech)

        Example (YAML):
          cooldown_minutes: 2
          snooze_window_minutes: 15
          pre_ring_grace_seconds: 5
          after_ring_window_seconds: 180
          no_dismiss_delay_seconds: 30
          dismiss_wait_timeout_seconds: 60
          post_dismiss_delay_seconds: 5
          clock_app_package_regex: "deskclock|clockpackage"
          tts_mode: announce
          max_events: 10
          debug_disable_tts: false
          debug_disable_llm: false
      default: {}
      selector:
        object: {}

mode: single
max_exceeded: silent

# Trigger: any selected next-alarm sensor changes
trigger:
  - platform: state
    entity_id: !input alarm_sensors

# Root-scope variables (simple inputs only)
variables:
  person_name: !input person_name
  extra_instructions: !input extra_instructions
  exclude_other_mentions: !input exclude_other_mentions
  first_ring_mode: !input first_ring_mode

action:
  # --- Read Advanced + gate (first-ring vs final-dismiss) + set initial speak time ---
  - variables:
      adv: !input advanced
      alarm_entities: !input alarm_sensors
      dismiss_sensor_entity: !input dismiss_sensor

      cooldown_minutes: "{{ adv.cooldown_minutes | default(3) }}"
      snooze_window_minutes: "{{ adv.snooze_window_minutes | default(20) }}"
      pre_ring_grace_seconds: "{{ adv.pre_ring_grace_seconds | default(5) }}"
      after_ring_window_seconds: "{{ adv.after_ring_window_seconds | default(120) }}"
      no_dismiss_delay_seconds: "{{ adv.no_dismiss_delay_seconds | default(30) }}"
      dismiss_wait_timeout_seconds: "{{ adv.dismiss_wait_timeout_seconds | default(60) }}"
      post_dismiss_delay_seconds: "{{ adv.post_dismiss_delay_seconds | default(2) }}"
      clock_app_package_regex: "{{ adv.clock_app_package_regex | default('deskclock|clockpackage|oneplus.deskclock|android.deskclock') }}"
      tts_mode: "{{ adv.tts_mode | default('tts') }}"
      max_events: "{{ adv.max_events | default(12) }}"
      retry_attempts: "{{ adv.retry_attempts | default(3) }}"
      retry_base_delay_ms: "{{ adv.retry_base_delay_ms | default(1200) }}"
      debug_disable_tts: "{{ adv.debug_disable_tts | default(false) }}"
      debug_disable_llm: "{{ adv.debug_disable_llm | default(false) }}"

      last_run_ts: "{{ as_timestamp(state_attr(this.entity_id, 'last_triggered') or 0) }}"
      cooldown_ok: "{{ (now().timestamp() - (last_run_ts | float(0))) > ((cooldown_minutes | int) * 60) }}"

      is_from_alarm_sensor: "{{ trigger.platform == 'state' and (trigger.entity_id in alarm_entities) }}"
      alarm_prev_iso: "{{ trigger.from_state.state if trigger.from_state else '' }}"
      alarm_next_iso: "{{ trigger.to_state.state   if trigger.to_state   else '' }}"
      prev_alarm_ts: "{{ as_timestamp(alarm_prev_iso, default=0) }}"
      next_alarm_ts: "{{ as_timestamp(alarm_next_iso, default=0) }}"
      now_ts: "{{ now().timestamp() }}"

      in_ring_window: "{{ is_from_alarm_sensor and (now_ts >= (prev_alarm_ts - (pre_ring_grace_seconds | int))) and (now_ts < (prev_alarm_ts + (after_ring_window_seconds | int))) }}"
      delta_seconds: "{{ (next_alarm_ts - prev_alarm_ts) if (next_alarm_ts and prev_alarm_ts) else 0 }}"
      looks_like_snooze: "{{ delta_seconds > 0 and delta_seconds <= ((snooze_window_minutes | int) * 60) }}"

      ok_first_ring: "{{ first_ring_mode and in_ring_window }}"
      ok_final_dismiss: "{{ (not first_ring_mode) and in_ring_window and (not looks_like_snooze) }}"
      should_run: "{{ (ok_first_ring or ok_final_dismiss) and cooldown_ok }}"

      # Initial target speak time (used ONLY if we don't get a real dismiss)
      speak_at_ts: "{{ (prev_alarm_ts + (no_dismiss_delay_seconds | int)) if (ok_first_ring or ok_final_dismiss) else now_ts }}"

  - condition: template
    value_template: "{{ should_run }}"

  # --- Optional wait: hold for a real DISMISS (via wait_template; no entity_id to validate) ---
  - choose:
      - conditions: "{{ dismiss_sensor_entity | string != '' }}"
        sequence:
          - variables:
              _dismiss_start_state: "{{ states(dismiss_sensor_entity) }}"
          - wait_template: >-
              {{ states(dismiss_sensor_entity) != _dismiss_start_state
                 and ((state_attr(dismiss_sensor_entity, 'package')
                       or state_attr(dismiss_sensor_entity, 'android.appInfo') or '') | lower
                       | regex_search(clock_app_package_regex)) }}
            timeout:
              seconds: "{{ dismiss_wait_timeout_seconds }}"
            continue_on_timeout: true

          - variables:
              dismiss_received: "{{ wait.completed | default(false) }}"
              dismiss_from_clock_app: "{{ dismiss_received }}"

              # After removal, check current next alarm on the same sensor that triggered the ring
              curr_next_iso: "{{ states(trigger.entity_id) if trigger and trigger.entity_id else '' }}"
              curr_next_ts: "{{ as_timestamp(curr_next_iso, default=0) }}"
              now2_ts: "{{ now().timestamp() }}"
              snooze_active_now: >-
                {{ dismiss_from_clock_app and (curr_next_ts > now2_ts)
                   and ((curr_next_ts - now2_ts) <= ((snooze_window_minutes | int) * 60)) }}

          # If it looks like a snooze, stop and wait for the snoozed ring cycle to retrigger
          - choose:
              - conditions: "{{ snooze_active_now }}"
                sequence:
                  - stop: "Alarm snoozed — skipping brief until next ring."

          # Otherwise, true dismiss: speak after configurable post-dismiss delay; if no valid dismiss, keep the no-dismiss schedule.
          - variables:
              speak_at_ts: >-
                {% if dismiss_from_clock_app %}
                  {{ now().timestamp() + (post_dismiss_delay_seconds | int) }}
                {% else %}
                  {{ speak_at_ts }}
                {% endif %}

  # --- Fetch today's events (and optional weather) ---
  - variables:
      start_dt: "{{ today_at('00:00:00') }}"
      end_dt:   "{{ as_datetime(as_timestamp(today_at('00:00:00')) + 86400) }}"
      weather_key: !input weather_entity

  - service: calendar.get_events
    target:
      entity_id: !input calendars
    data:
      start_date_time: "{{ start_dt }}"
      end_date_time: "{{ end_dt }}"
    response_variable: agenda

  - choose:
      - conditions: "{{ weather_key | string != '' }}"
        sequence:
          - service: weather.get_forecasts
            target:
              entity_id: !input weather_entity
            data:
              type: daily
            response_variable: forecast
          - variables:
              today_forecast: >-
                {% set key = weather_key %}
                {% if forecast and forecast is mapping and (key in forecast)
                      and ('forecast' in forecast[key]) and (forecast[key]['forecast'] | count) > 0 %}
                  {{ forecast[key]['forecast'][0] }}
                {% else %}{}{% endif %}
    default:
      - variables:
          today_forecast: {}

  # --- Flatten + @mention filter (case-insensitive), HA Jinja-safe ---
  - variables:
      person_lc: "{{ (person_name | lower | trim) }}"
      events_flat: >-
        {% set ns = namespace(items=[]) %}
        {% for cal in agenda %}
          {% set payload = agenda[cal] %}
          {% if payload is mapping and 'events' in payload %}
            {% for e in payload['events'] %}
              {% set summary = (e['summary'] if 'summary' in e else '') %}
              {% set s = summary | lower %}
              {% set has_any_tag = (s | regex_search('@[\\w-]+')) if (exclude_other_mentions) else false %}
              {% set tagged_me = (exclude_other_mentions and (person_lc|length > 0)
                                   and (s | regex_search('(^|\\W)@' ~ person_lc ~ '(\\W|$)'))) %}
              {% set tagged_all = (exclude_other_mentions and (s | regex_search('(^|\\W)@all(\\W|$)'))) %}
              {% set include = (not exclude_other_mentions) or tagged_me or tagged_all or (not has_any_tag) %}
              {% if include %}
                {% set start = e['start'] %}
                {% set all_day = (start is string and start|length == 10) %}
                {% set sort_key = (start ~ 'T00:00:00') if all_day else start %}
                {% set ns.items = ns.items + [ {
                  'calendar': cal,
                  'summary': summary,
                  'start': start,
                  'end': e['end'],
                  'all_day': all_day,
                  'sort_key': sort_key
                } ] %}
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        {{ (ns.items | sort(attribute='sort_key'))[: (max_events | int) ] }}

  # --- De-duplicate events by (lowercased summary + start time) ---
  - variables:
      events_dedup: >-
        {% set ns = namespace(items=[], seen=[]) %}
        {% for e in events_flat %}
          {% set key = (e.summary | lower | trim) ~ '|' ~ (e.start | string) %}
          {% if key not in ns.seen %}
            {% set ns.seen = ns.seen + [key] %}
            {% set ns.items = ns.items + [e] %}
          {% endif %}
        {% endfor %}
        {{ ns.items }}

  # --- LLM prompt + retries (skippable via debug flag) ---
  - variables:
      llm_prompt: >-
        You are generating a short morning briefing to be spoken by Alexa{% if person_name|trim %} to {{ person_name }}{% endif %}.
        Use British date/time conventions.
        {% if extra_instructions|trim %}Additional instructions: {{ extra_instructions }}{% endif %}
        Input data is JSON:
        {
          "date_iso": "{{ now().date().isoformat() }}",
          "events": {{ events_dedup | tojson }},
          "weather_today": {{ today_forecast | tojson }}
        }
        Rules:
        - Start with weekday and date{{ ' and a one-line weather headline (temp highs/lows; mention rain chance if present)' if today_forecast else '' }}.
        - If weather_today is empty, omit the weather entirely.
        - List key events in chronological order with clear times (e.g., "at 08:30, GCSE Physics revision; at 11:00, dentist").
        - If multiple entries describe the same event (same time and similar title), mention it once (deduplicate).
        - For all-day events just say "(all day)".
        - If there are no events, say that explicitly and give a brief encouragement.
        - Keep to about 3–6 short sentences. No markup; plain text only.
        - If no name is provided, do not address the listener by name.

      speech_final: ""
  - choose:
      - conditions: "{{ not debug_disable_llm }}"
        sequence:
          - repeat:
              until:
                - condition: template
                  value_template: >-
                    {{ (repeat.index >= (retry_attempts | int)) or ((speech_final | default('') | trim) != '') }}
              sequence:
                - service: conversation.process
                  data:
                    agent_id: !input openai_agent
                    text: "{{ llm_prompt }}"
                  response_variable: llm

                - variables:
                    speech_try: >-
                      {{ llm.response.speech.plain.speech
                         if llm is defined and llm.response is defined
                         and llm.response.speech is defined and llm.response.speech.plain is defined
                         else '' }}

                - choose:
                    - conditions: "{{ speech_try | trim != '' }}"
                      sequence:
                        - variables:
                            speech_final: "{{ speech_try }}"
                    - conditions: "{{ speech_try | trim == '' }}"
                      sequence:
                        - delay:
                            milliseconds: >-
                              {{ (retry_base_delay_ms | int) * (2 ** (repeat.index - 1)) }}
    default: []

  # --- Fallback text and final speech selection ---
  - variables:
      tts_mode: "{{ tts_mode }}"
      speech_basic: >-
        {% set parts = [] %}
        {% set greeting = 'Morning' ~ ( ' ' ~ person_name if person_name|trim else '' ) ~ '.' %}
        {% if today_forecast %}
          {% set cond = today_forecast.condition | default('') %}
          {% set hi = today_forecast.temperature | default('?') %}
          {% set lo = today_forecast.templow | default('?') %}
          {% set parts = parts + [ greeting ~ ' Today: ' ~ cond ~ ', high ' ~ hi ~ '°, low ' ~ lo ~ '°.' ] %}
        {% else %}
          {% set parts = parts + [ greeting ] %}
        {% endif %}
        {% if events_dedup | count == 0 %}
          {% set parts = parts + ['No events in the calendar. Have a great day!'] %}
        {% else %}
          {% set parts = parts + ['Here are your events:'] %}
          {% for e in events_dedup %}
            {% if e.all_day %}
              {% set line = e.summary ~ ' (all day)' %}
            {% else %}
              {% set line = (e.start[11:16]) ~ ': ' ~ e.summary %}
            {% endif %}
            {% set parts = parts + [line] %}
          {% endfor %}
        {% endif %}
        {{ (parts | join(' '))[:790] }}
      speech: "{{ (speech_final | default('') | trim) if (speech_final | default('') | trim) != '' else speech_basic }}"

  # --- Final snooze guard (works even without dismiss sensor) ---
  - variables:
      min_next_alarm_delta: >-
        {% set deltas = [] %}
        {% for s in alarm_entities %}
          {% set state = states(s) %}
          {% set ts = as_timestamp(state, default=0) %}
          {% if ts > 0 %}
            {% set deltas = deltas + [ ts - now().timestamp() ] %}
          {% endif %}
        {% endfor %}
        {{ (deltas | min) if (deltas | count) > 0 else 999999 }}

  - condition: template
    value_template: >-
      {{ not (min_next_alarm_delta > 0 and min_next_alarm_delta <= ((snooze_window_minutes | int) * 60)) }}

  # --- Delay until intended speak time (remaining time only), then speak on Alexa ---
  - variables:
      remaining_delay_seconds: "{{ max(0, (speak_at_ts - now().timestamp()) | int) }}"
  - choose:
      - conditions: "{{ remaining_delay_seconds > 0 }}"
        sequence:
          - delay:
              seconds: "{{ remaining_delay_seconds }}"

  - choose:
      - conditions: "{{ not debug_disable_tts }}"
        sequence:
          - service: notify.alexa_media
            data:
              target: !input alexa_targets
              message: "{{ speech[:790] }}"
              data:
                type: "{{ tts_mode }}"
    default: []
