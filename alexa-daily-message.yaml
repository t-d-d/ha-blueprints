blueprint:
  name: My Daily Briefing — Alarm Calendar & Weather (Echo + Any TTS)
  description: >
    Speaks today’s calendar (optional weather & LLM) when your phone/Echo alarm fires.
    Works with Echo via Alexa Media Player or any speaker via a TTS engine (e.g., Piper).
    Snooze-aware; supports @mentions (e.g., @Ana, @all). LLM agent is optional.
    NEW: optional set/restore speaker volume before/after speaking.
  domain: automation

  input:
    # --- Core (simple) ---
    alarm_sensors:
      name: Next-alarm sensors
      description: "Choose timestamp sensors like sensor.*_next_alarm from phones/Echos."
      selector:
        entity:
          multiple: true
          filter:
            - domain: sensor
              device_class: timestamp
              integration: mobile_app
            - domain: sensor
              device_class: timestamp
              integration: alexa_media

    dismiss_sensor:
      name: Phone 'Last Removed Notification' sensor (optional)
      description: "sensor.<phone>_last_removed_notification — used to speak after DISMISS; falls back if missing/timeout."
      default: ""
      selector:
        entity:
          domain: sensor

    first_ring_mode:
      name: Announce on first ring
      description: "On = speak at first ring (even if snoozed). Off = wait for final dismiss (heuristic)."
      default: false
      selector:
        boolean: {}

    # One combined targets list — Echo + other media players
    speak_targets:
      name: Speakers (any)
      description: "Pick any media_player(s): Echo, Sonos, Nest, Chromecast, etc."
      selector:
        entity:
          domain: media_player
          multiple: true

    # Optional engine for non-Alexa targets (Piper, Google Cloud, Polly, etc.)
    tts_engine:
      name: TTS engine for non-Alexa (optional)
      description: "Required only for non-Alexa players. Example: tts.piper"
      default: ""
      selector:
        entity:
          domain: tts

    # --- NEW: Volume control ---
    set_volume:
      name: Set speaker volume
      description: "If on, set volume for all selected players before speaking."
      default: false
      selector:
        boolean: {}

    speak_volume:
      name: Speaking volume
      description: "0.00–1.00 (used only if 'Set speaker volume' is on)."
      default: 0.35
      selector:
        number:
          min: 0
          max: 1
          step: 0.05
          mode: slider

    restore_volume:
      name: Restore previous volume after speaking
      default: true
      selector:
        boolean: {}

    calendars:
      name: Calendars to include
      selector:
        entity:
          domain: calendar
          multiple: true

    weather_entity:
      name: Weather entity (optional)
      default: ""
      selector:
        entity:
          domain: weather

    person_name:
      name: Person name (optional; leave blank to omit)
      default: ""
      selector:
        text: {}

    extra_instructions:
      name: Extra instructions (optional)
      description: "Additional prompt text the model should follow (tone, phrasing, constraints, etc.)"
      default: ""
      selector:
        text: {}

    exclude_other_mentions:
      name: Exclude events @'ed to others
      description: "On = include only untagged items, @<your name>, or @all"
      default: true
      selector:
        boolean: {}

    openai_agent:
      name: LLM agent (optional)
      description: "Select your Conversation agent (e.g., conversation.openai). Leave blank to skip LLM and use fallback narration."
      default: ""
      selector:
        entity:
          domain: conversation

    # --- Advanced (all optional; clear names, safe defaults) ---
    advanced:
      name: Advanced (optional)
      description: >
        Paste YAML/JSON with fields (defaults shown):

        cooldown_minutes: 3
        snooze_window_minutes: 20
        pre_ring_grace_seconds: 5
        after_ring_window_seconds: 120
        no_dismiss_delay_seconds: 30
        dismiss_wait_timeout_seconds: 60
        post_dismiss_delay_seconds: 5
        clock_app_package_regex: "deskclock|clockpackage|oneplus.deskclock|android.deskclock"
        tts_mode: "tts"     # Alexa: "tts" or "announce"
        max_events: 12
        retry_attempts: 3
        retry_base_delay_ms: 1200

        # Debug/timing:
        debug_disable_tts: false         # skip playback entirely
        debug_disable_llm: false         # skip LLM (use fallback text)
        llm_after_delay: true            # run LLM after the final delay (safer)

        Example (YAML):
          cooldown_minutes: 1
          snooze_window_minutes: 15
          pre_ring_grace_seconds: 5
          after_ring_window_seconds: 180
          no_dismiss_delay_seconds: 30
          dismiss_wait_timeout_seconds: 60
          post_dismiss_delay_seconds: 5
          clock_app_package_regex: "deskclock|clockpackage"
          tts_mode: announce
          max_events: 10
          debug_disable_tts: false
          debug_disable_llm: false
          llm_after_delay: true
      default: {}
      selector:
        object: {}

mode: single
max_exceeded: silent

trigger:
  - platform: state
    entity_id: !input alarm_sensors

variables:
  person_name: !input person_name
  extra_instructions: !input extra_instructions
  exclude_other_mentions: !input exclude_other_mentions
  first_ring_mode: !input first_ring_mode

action:
  # --- Read Advanced + gate ---
  - variables:
      adv: !input advanced
      alarm_entities: !input alarm_sensors
      dismiss_sensor_entity: !input dismiss_sensor
      agent_entity: !input openai_agent
      weather_key: !input weather_entity

      # Volume inputs
      set_volume: !input set_volume
      speak_volume: !input speak_volume
      restore_volume: !input restore_volume

      cooldown_minutes: "{{ adv.cooldown_minutes | default(3) }}"
      snooze_window_minutes: "{{ adv.snooze_window_minutes | default(20) }}"
      pre_ring_grace_seconds: "{{ adv.pre_ring_grace_seconds | default(5) }}"
      after_ring_window_seconds: "{{ adv.after_ring_window_seconds | default(120) }}"
      no_dismiss_delay_seconds: "{{ adv.no_dismiss_delay_seconds | default(30) }}"
      dismiss_wait_timeout_seconds: "{{ adv.dismiss_wait_timeout_seconds | default(60) }}"
      post_dismiss_delay_seconds: "{{ adv.post_dismiss_delay_seconds | default(5) }}"
      clock_app_package_regex: "{{ adv.clock_app_package_regex | default('deskclock|clockpackage|oneplus.deskclock|android.deskclock') }}"
      tts_mode: "{{ adv.tts_mode | default('tts') }}"
      max_events: "{{ adv.max_events | default(12) }}"
      retry_attempts: "{{ adv.retry_attempts | default(3) }}"
      retry_base_delay_ms: "{{ adv.retry_base_delay_ms | default(1200) }}"
      debug_disable_tts: "{{ adv.debug_disable_tts | default(false) }}"
      debug_disable_llm: "{{ adv.debug_disable_llm | default(false) }}"
      llm_after_delay: "{{ adv.llm_after_delay | default(true) }}"

      last_run_ts: "{{ as_timestamp(state_attr(this.entity_id, 'last_triggered') or 0) }}"
      cooldown_ok: "{{ (now().timestamp() - (last_run_ts | float(0))) > ((cooldown_minutes | int) * 60) }}"

      is_from_alarm_sensor: "{{ trigger.platform == 'state' and (trigger.entity_id in alarm_entities) }}"
      alarm_prev_iso: "{{ trigger.from_state.state if trigger.from_state else '' }}"
      alarm_next_iso: "{{ trigger.to_state.state   if trigger.to_state   else '' }}"
      prev_alarm_ts: "{{ as_timestamp(alarm_prev_iso, default=0) }}"
      next_alarm_ts: "{{ as_timestamp(alarm_next_iso, default=0) }}"
      now_ts: "{{ now().timestamp() }}"

      in_ring_window: "{{ is_from_alarm_sensor and (now_ts >= (prev_alarm_ts - (pre_ring_grace_seconds | int))) and (now_ts < (prev_alarm_ts + (after_ring_window_seconds | int))) }}"
      delta_seconds: "{{ (next_alarm_ts - prev_alarm_ts) if (next_alarm_ts and prev_alarm_ts) else 0 }}"
      looks_like_snooze: "{{ delta_seconds > 0 and delta_seconds <= ((snooze_window_minutes | int) * 60) }}"

      ok_first_ring: "{{ first_ring_mode and in_ring_window }}"
      ok_final_dismiss: "{{ (not first_ring_mode) and in_ring_window and (not looks_like_snooze) }}"
      should_run: "{{ (ok_first_ring or ok_final_dismiss) and cooldown_ok }}"

      speak_at_ts: "{{ (prev_alarm_ts + (no_dismiss_delay_seconds | int)) if (ok_first_ring or ok_final_dismiss) else now_ts }}"

  - condition: template
    value_template: "{{ should_run }}"

  # --- Optional wait for real dismiss (via wait_template; no entity_id validation) ---
  - choose:
      - conditions: "{{ dismiss_sensor_entity | string != '' }}"
        sequence:
          - variables:
              _dismiss_start_state: "{{ states(dismiss_sensor_entity) }}"
          - wait_template: >-
              {{ states(dismiss_sensor_entity) != _dismiss_start_state
                 and ((state_attr(dismiss_sensor_entity, 'package')
                       or state_attr(dismiss_sensor_entity, 'android.appInfo') or '') | lower
                       | regex_search(clock_app_package_regex)) }}
            timeout:
              seconds: "{{ dismiss_wait_timeout_seconds }}"
            continue_on_timeout: true

          - variables:
              dismiss_received: "{{ wait.completed | default(false) }}"
              dismiss_from_clock_app: "{{ dismiss_received }}"
              curr_next_iso: "{{ states(trigger.entity_id) if trigger and trigger.entity_id else '' }}"
              curr_next_ts: "{{ as_timestamp(curr_next_iso, default=0) }}"
              now2_ts: "{{ now().timestamp() }}"
              snooze_active_now: >-
                {{ dismiss_from_clock_app and (curr_next_ts > now2_ts)
                   and ((curr_next_ts - now2_ts) <= ((snooze_window_minutes | int) * 60)) }}

          - choose:
              - conditions: "{{ snooze_active_now }}"
                sequence:
                  - stop: "Alarm snoozed — skipping update until next ring."

          - variables:
              speak_at_ts: >-
                {% if dismiss_from_clock_app %}
                  {{ now().timestamp() + (post_dismiss_delay_seconds | int) }}
                {% else %}
                  {{ speak_at_ts }}
                {% endif %}

  # --- Fetch today's events (and optional weather) ---
  - variables:
      start_dt: "{{ today_at('00:00:00') }}"
      end_dt:   "{{ as_datetime(as_timestamp(today_at('00:00:00')) + 86400) }}"

  - service: calendar.get_events
    target:
      entity_id: !input calendars
    data:
      start_date_time: "{{ start_dt }}"
      end_date_time: "{{ end_dt }}"
    response_variable: agenda

  - choose:
      - conditions: "{{ weather_key | string != '' }}"
        sequence:
          - service: weather.get_forecasts
            target:
              entity_id: !input weather_entity
            data:
              type: daily
            response_variable: forecast
          - variables:
              today_forecast: >-
                {% set key = weather_key %}
                {% if forecast and forecast is mapping and (key in forecast)
                      and ('forecast' in forecast[key]) and (forecast[key]['forecast'] | count) > 0 %}
                  {{ forecast[key]['forecast'][0] }}
                {% else %}{}{% endif %}
    default:
      - variables:
          today_forecast: {}

  # --- Flatten + @mention filter (case-insensitive) ---
  - variables:
      person_lc: "{{ (person_name | lower | trim) }}"
      events_flat: >-
        {% set ns = namespace(items=[]) %}
        {% for cal in agenda %}
          {% set payload = agenda[cal] %}
          {% if payload is mapping and 'events' in payload %}
            {% for e in payload['events'] %}
              {% set summary = (e['summary'] if 'summary' in e else '') %}
              {% set s = summary | lower %}
              {% set has_any_tag = (s | regex_search('@[\\w-]+')) if (exclude_other_mentions) else false %}
              {% set tagged_me = (exclude_other_mentions and (person_lc|length > 0)
                                   and (s | regex_search('(^|\\W)@' ~ person_lc ~ '(\\W|$)'))) %}
              {% set tagged_all = (exclude_other_mentions and (s | regex_search('(^|\\W)@all(\\W|$)'))) %}
              {% set include = (not exclude_other_mentions) or tagged_me or tagged_all or (not has_any_tag) %}
              {% if include %}
                {% set start = e['start'] %}
                {% set all_day = (start is string and start|length == 10) %}
                {% set sort_key = (start ~ 'T00:00:00') if all_day else start %}
                {% set ns.items = ns.items + [ {
                  'calendar': cal,
                  'summary': summary,
                  'start': start,
                  'end': e['end'],
                  'all_day': all_day,
                  'sort_key': sort_key
                } ] %}
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        {{ (ns.items | sort(attribute='sort_key'))[: (max_events | int) ] }}

  - variables:
      events_dedup: >-
        {% set ns = namespace(items=[], seen=[]) %}
        {% for e in events_flat %}
          {% set key = (e.summary | lower | trim) ~ '|' ~ (e.start | string) %}
          {% if key not in ns.seen %}
            {% set ns.seen = ns.seen + [key] %}
            {% set ns.items = ns.items + [e] %}
          {% endif %}
        {% endfor %}
        {{ ns.items }}

  # --- Build prompt + (optional) LLM ---
  - variables:
      llm_prompt: >-
        You are generating a short morning update to be spoken{% if person_name|trim %} to {{ person_name }}{% endif %}.
        Use British date/time conventions.
        {% if extra_instructions|trim %}Additional instructions: {{ extra_instructions }}{% endif %}
        Input data is JSON:
        {
          "date_iso": "{{ now().date().isoformat() }}",
          "events": {{ events_dedup | tojson }},
          "weather_today": {{ today_forecast | tojson }}
        }
        Rules:
        - Start with weekday and date{{ ' and a one-line weather headline (temp highs/lows; mention rain chance if present)' if today_forecast else '' }}.
        - If weather_today is empty, omit the weather entirely.
        - List key events in chronological order with clear times.
        - If duplicates describe the same event/time, mention it once.
        - For all-day events, say "(all day)".
        - If no events, say so with a brief encouragement.
        - Keep to ~3–6 short sentences. Plain text only.
        - If no name is provided, do not address the listener by name.

      speech_final: ""
      retry_attempts: "{{ retry_attempts }}"
      retry_base_delay_ms: "{{ retry_base_delay_ms }}"

  - choose:
      - conditions: "{{ (agent_entity | string != '') and (not llm_after_delay) and (not debug_disable_llm) }}"
        sequence:
          - repeat:
              until:
                - condition: template
                  value_template: "{{ (repeat.index >= (retry_attempts | int)) or ((speech_final | default('') | trim) != '') }}"
              sequence:
                - service: conversation.process
                  data:
                    agent_id: "{{ agent_entity }}"
                    text: "{{ llm_prompt }}"
                  response_variable: llm
                - variables:
                    speech_try: >-
                      {{ llm.response.speech.plain.speech
                         if llm and llm.response and llm.response.speech and llm.response.speech.plain
                         else '' }}
                - choose:
                    - conditions: "{{ speech_try | trim != '' }}"
                      sequence:
                        - variables:
                            speech_final: "{{ speech_try }}"
                    - conditions: "{{ speech_try | trim == '' }}"
                      sequence:
                        - delay:
                            milliseconds: "{{ (retry_base_delay_ms | int) * (2 ** (repeat.index - 1)) }}"
    default: []

  # --- Delay until speak time ---
  - variables:
      remaining_delay_seconds: "{{ max(0, (speak_at_ts - now().timestamp()) | int) }}"
  - choose:
      - conditions: "{{ remaining_delay_seconds > 0 }}"
        sequence:
          - delay:
              seconds: "{{ remaining_delay_seconds }}"

  # Post-delay snooze guard
  - variables:
      min_next_alarm_delta: >-
        {% set deltas = [] %}
        {% for s in alarm_entities %}
          {% set state = states(s) %}
          {% set ts = as_timestamp(state, default=0) %}
          {% if ts > 0 %}
            {% set deltas = deltas + [ ts - now().timestamp() ] %}
          {% endif %}
        {% endfor %}
        {{ (deltas | min) if (deltas | count) > 0 else 999999 }}

  - condition: template
    value_template: "{{ not (min_next_alarm_delta > 0 and min_next_alarm_delta <= ((snooze_window_minutes | int) * 60)) }}"

  # Safe mode: run LLM AFTER delay (optional)
  - choose:
      - conditions: "{{ (agent_entity | string != '') and llm_after_delay and (not debug_disable_llm) }}"
        sequence:
          - repeat:
              until:
                - condition: template
                  value_template: "{{ (repeat.index >= (retry_attempts | int)) or ((speech_final | default('') | trim) != '') }}"
              sequence:
                - service: conversation.process
                  data:
                    agent_id: "{{ agent_entity }}"
                    text: "{{ llm_prompt }}"
                  response_variable: llm
                - variables:
                    speech_try: >-
                      {{ llm.response.speech.plain.speech
                         if llm and llm.response and llm.response.speech and llm.response.speech.plain
                         else '' }}
                - choose:
                    - conditions: "{{ speech_try | trim != '' }}"
                      sequence:
                        - variables:
                            speech_final: "{{ speech_try }}"
                    - conditions: "{{ speech_try | trim == '' }}"
                      sequence:
                        - delay:
                            milliseconds: "{{ (retry_base_delay_ms | int) * (2 ** (repeat.index - 1)) }}"
    default: []

  # --- Fallback + final speech ---
  - variables:
      final_speech_fallback: >-
        {% set parts = [] %}
        {% set greeting = 'Morning' ~ ( ' ' ~ person_name if person_name|trim else '' ) ~ '.' %}
        {% if today_forecast %}
          {% set cond = today_forecast.condition | default('') %}
          {% set hi = today_forecast.temperature | default('?') %}
          {% set lo = today_forecast.templow | default('?') %}
          {% set parts = parts + [ greeting ~ ' Today: ' ~ cond ~ ', high ' ~ hi ~ '°, low ' ~ lo ~ '°.' ] %}
        {% else %}
          {% set parts = parts + [ greeting ] %}
        {% endif %}
        {% if events_dedup | count == 0 %}
          {% set parts = parts + ['No events in the calendar. Have a great day!'] %}
        {% else %}
          {% set parts = parts + ['Here are your events:'] %}
          {% for e in events_dedup %}
            {% if e.all_day %}
              {% set line = e.summary ~ ' (all day)' %}
            {% else %}
              {% set line = (e.start[11:16]) ~ ': ' ~ e.summary %}
            {% endif %}
            {% set parts = parts + [line] %}
          {% endfor %}
        {% endif %}
        {{ (parts | join(' '))[:790] }}
      speech: "{{ (speech_final | default('') | trim) if (speech_final | default('') | trim) != '' else final_speech_fallback }}"

  # --- Split speak_targets into Alexa vs non-Alexa ---
  - variables:
      all_targets: !input speak_targets
      alexa_targets: >-
        {% set out = [] %}
        {% for e in all_targets %}
          {% set dev = device_id(e) %}
          {% set ids = device_attr(dev, 'identifiers') or [] %}
          {% set is_alexa = false %}
          {% for pair in ids %}
            {% set p0 = (pair[0] if (pair is sequence and (pair | count) > 0) else '') %}
            {% if p0 == 'alexa_media' %}
              {% set is_alexa = true %}
            {% endif %}
          {% endfor %}
          {% if is_alexa %}
            {% set out = out + [e] %}
          {% endif %}
        {% endfor %}
        {{ out }}
      generic_targets: >-
        {% set out = [] %}
        {% for e in all_targets %}
          {% set dev = device_id(e) %}
          {% set ids = device_attr(dev, 'identifiers') or [] %}
          {% set is_alexa = false %}
          {% for pair in ids %}
            {% set p0 = (pair[0] if (pair is sequence and (pair | count) > 0) else '') %}
            {% if p0 == 'alexa_media' %}
              {% set is_alexa = true %}
            {% endif %}
          {% endfor %}
          {% if not is_alexa %}
            {% set out = out + [e] %}
          {% endif %}
        {% endfor %}
        {{ out }}
      tts_engine_entity: !input tts_engine

  # --- Preflight validation & user feedback ---
  - variables:
      alexa_service_ok: "{{ has_service('notify', 'alexa_media') }}"
      alexa_count: "{{ alexa_targets | count }}"
      generic_count: "{{ generic_targets | count }}"
      tts_engine_ok: "{{ tts_engine_entity | string != '' }}"

  - choose:
      - conditions: "{{ alexa_count > 0 and not alexa_service_ok }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "Daily Briefing: Alexa TTS unavailable"
              message: >-
                You selected Alexa devices ({{ alexa_targets | join(', ') }}), but the
                service notify.alexa_media is not available. Install/enable Alexa Media Player,
                or remove those targets. Proceeding with non-Alexa targets only.

  - choose:
      - conditions: "{{ generic_count > 0 and not tts_engine_ok }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "Daily Briefing: No TTS engine for non-Alexa"
              message: >-
                You selected non-Alexa players ({{ generic_targets | join(', ') }}), but no
                TTS engine was set. Choose a TTS entity (e.g., tts.piper) in the automation.
                Proceeding with Alexa targets only (if any).

  - choose:
      - conditions: >-
          {{ not (
              (alexa_count > 0 and alexa_service_ok)
              or
              (generic_count > 0 and tts_engine_ok)
            ) }}
        sequence:
          - service: persistent_notification.create
            data:
              title: "Daily Briefing: No usable speakers"
              message: >-
                None of the selected speakers can be used:
                Alexa service missing and/or no TTS engine for non-Alexa.
                Update the automation’s outputs and try again.
          - stop: "No usable speakers (see notification)."

  # --- NEW: Capture current volumes & set speaking volume (if enabled) ---
  - variables:
      usable_targets: >-
        {% set out = [] %}
        {% if alexa_service_ok %}
          {% for e in alexa_targets %}{% set out = out + [e] %}{% endfor %}
        {% endif %}
        {% if tts_engine_ok %}
          {% for e in generic_targets %}{% set out = out + [e] %}{% endfor %}
        {% endif %}
        {{ out }}
      prev_volumes: []

  - choose:
      - conditions: "{{ set_volume and (usable_targets | count) > 0 }}"
        sequence:
          - variables:
              prev_volumes: >-
                {% set out = [] %}
                {% for e in usable_targets %}
                  {% set v = state_attr(e, 'volume_level') %}
                  {% if v is number %}
                    {% set out = out + [ {'entity': e, 'level': v} ] %}
                  {% endif %}
                {% endfor %}
                {{ out }}
          - repeat:
              for_each: "{{ usable_targets }}"
              sequence:
                - service: media_player.volume_set
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    volume_level: "{{ speak_volume }}"

  # --- Speak on Alexa (alexa_media) ---
  - choose:
      - conditions: "{{ (not debug_disable_tts) and (alexa_count > 0) and alexa_service_ok }}"
        sequence:
          - service: notify.alexa_media
            data:
              target: "{{ alexa_targets }}"
              message: "{{ speech[:790] }}"
              data:
                type: "{{ tts_mode }}"
    default: []

  # --- Speak on non-Alexa (generic TTS engine) ---
  - choose:
      - conditions: "{{ (not debug_disable_tts) and tts_engine_ok and (generic_count > 0) }}"
        sequence:
          - repeat:
              for_each: "{{ generic_targets }}"
              sequence:
                - service: tts.speak
                  target:
                    entity_id: "{{ tts_engine_entity }}"
                  data:
                    media_player_entity_id: "{{ repeat.item }}"
                    message: "{{ speech }}"
    default: []

  # --- NEW: Restore previous volumes (if captured) ---
  - choose:
      - conditions: "{{ set_volume and restore_volume and (prev_volumes | count) > 0 }}"
        sequence:
          - repeat:
              for_each: "{{ prev_volumes }}"
              sequence:
                - service: media_player.volume_set
                  target:
                    entity_id: "{{ repeat.item.entity }}"
                  data:
                    volume_level: "{{ repeat.item.level }}"
    default: []
