blueprint:
  name: Alexa Alarm Brief
  description: >
    Speak a short morning brief on Alexa when an alarm rings (first ring) or after final dismiss.
    Works with sensor.*_next_alarm from Alexa Media Player (Echo) and Android HA Companion (phones).
    Optionally wait for Android Companion “Last Removed Notification” (dismiss) with timeout fallback.
    Optional weather; OpenAI Conversation formatting with retries + fallback; cooldown (under “Advanced”).
  domain: automation

  input:
    # --- Core (simple) ---
    alarm_sensors:
      name: Next-alarm sensors
      description: "sensor.bedroom_echo_next_alarm, sensor.pixel_7_next_alarm, etc."
      selector:
        entity:
          domain: sensor
          multiple: true

    # Optional: phone dismiss sensor (Companion App → Notification sensors → Last Removed Notification)
    dismiss_sensor:
      name: Phone 'Last Removed Notification' sensor (optional)
      description: "sensor.<phone>_last_removed_notification — used to speak right after DISMISS; falls back if missing/timeout."
      selector:
        entity:
          domain: sensor

    first_ring_mode:
      name: Announce on first ring
      description: "On = speak at first ring (even if snoozed). Off = wait for final dismiss (heuristic)."
      default: false
      selector:
        boolean: {}

    alexa_targets:
      name: Alexa device(s) to speak on
      selector:
        entity:
          domain: media_player
          multiple: true

    calendars:
      name: Calendars to include
      selector:
        entity:
          domain: calendar
          multiple: true

    include_weather:
      name: Include weather
      default: false
      selector:
        boolean: {}

    weather_entity:
      name: Weather entity (used only if Include weather = on)
      selector:
        entity:
          domain: weather

    person_name:
      name: Person name (optional; leave blank to omit)
      default: ""
      selector:
        text: {}

    extra_instructions:
      name: Extra instructions (optional)
      description: "Additional prompt text the model should follow (tone, phrasing, constraints, etc.)"
      default: ""
      selector:
        text: {}

    exclude_other_mentions:
      name: Exclude events @'ed to others
      description: "On = include only untagged items, @<your name>, or @all"
      default: true
      selector:
        boolean: {}

    openai_agent:
      name: Conversation agent (OpenAI Conversation)
      description: "Usually conversation.openai"
      default: conversation.openai
      selector:
        entity:
          domain: conversation

    # --- Advanced (all optional; safe defaults) ---
    advanced:
      name: Advanced (optional)
      description: >
        Paste YAML or JSON with any of these fields (all optional; defaults shown):

        cooldown_minutes (int, default 3)
        snooze_threshold_min (int, default 20)
        window_before_fire_s (int, default 5)      # grace: allow sensor to flip up to 5s before alarm time
        window_after_fire_s (int, default 120)     # accept sensor updates this long after alarm time
        post_alarm_delay_s (int, default 30)       # fallback speak delay after alarm time if no dismiss
        dismiss_wait_timeout_s (int, default 60)   # how long to wait for 'Last Removed Notification' before fallback
        clock_package_pattern (str, default "deskclock|clockpackage|oneplus.deskclock|android.deskclock")  # regex match on package
        tts_mode (str: "tts" or "announce", default "tts")
        max_events (int, default 12)
        retry_attempts (int, default 3)
        retry_delay_ms (int, default 1200)

        Example (YAML):
          cooldown_minutes: 2
          snooze_threshold_min: 15
          window_before_fire_s: 5
          window_after_fire_s: 180
          post_alarm_delay_s: 45
          dismiss_wait_timeout_s: 60
          tts_mode: announce
          max_events: 10
      default: {}
      selector:
        object: {}

mode: single
max_exceeded: silent

# Trigger: any selected next-alarm sensor changes
trigger:
  - platform: state
    entity_id: !input alarm_sensors

# Root-scope variables (simple inputs only)
variables:
  v_person: !input person_name
  v_extra: !input extra_instructions
  v_include_weather: !input include_weather
  v_excl_others: !input exclude_other_mentions
  v_first_ring: !input first_ring_mode

action:
  # --- Read Advanced + gate (first-ring vs final-dismiss) + set initial speak time ---
  - variables:
      _adv: !input advanced
      _sensors: !input alarm_sensors
      _dismiss_sensor: !input dismiss_sensor

      _cool_min: "{{ _adv.cooldown_minutes | default(3) }}"
      _snooze_thr_m: "{{ _adv.snooze_threshold_min | default(20) }}"
      _pre_grace_s: "{{ _adv.window_before_fire_s | default(5) }}"
      _win_after_s: "{{ _adv.window_after_fire_s | default(120) }}"
      _post_delay_s: "{{ _adv.post_alarm_delay_s | default(30) }}"
      _dismiss_timeout_s: "{{ _adv.dismiss_wait_timeout_s | default(60) }}"
      _clock_pkg_pat: "{{ _adv.clock_package_pattern | default('deskclock|clockpackage|oneplus.deskclock|android.deskclock') }}"
      v_tts_mode: "{{ _adv.tts_mode | default('tts') }}"
      v_max_events: "{{ _adv.max_events | default(12) }}"
      v_max_tries: "{{ _adv.retry_attempts | default(3) }}"
      v_base_delay_ms: "{{ _adv.retry_delay_ms | default(1200) }}"

      _last_ts: "{{ as_timestamp(state_attr(this.entity_id, 'last_triggered') or 0) }}"
      _cool_ok: "{{ (now().timestamp() - (_last_ts | float(0))) > ((_cool_min | int) * 60) }}"

      _is_sensor: "{{ trigger.platform == 'state' and (trigger.entity_id in _sensors) }}"
      _prev: "{{ trigger.from_state.state if trigger.from_state else '' }}"
      _next: "{{ trigger.to_state.state   if trigger.to_state   else '' }}"
      _prev_ok: "{{ _prev not in ['unknown','unavailable','','None',None] }}"
      _next_ok: "{{ _next not in ['unknown','unavailable','','None',None] }}"
      _prev_ts: "{{ as_timestamp(_prev) if _prev_ok else 0 }}"
      _next_ts: "{{ as_timestamp(_next) if _next_ok else 0 }}"
      _now_ts:  "{{ now().timestamp() }}"

      _fired_recently: "{{ _is_sensor and (_now_ts >= (_prev_ts - (_pre_grace_s | int))) and (_now_ts < (_prev_ts + (_win_after_s | int))) }}"
      _delta_s: "{{ (_next_ts - _prev_ts) if (_next_ts and _prev_ts) else 0 }}"
      _looks_snooze: "{{ _delta_s > 0 and _delta_s <= ((_snooze_thr_m | int) * 60) }}"

      _ok_first_ring: "{{ v_first_ring and _fired_recently }}"
      _ok_final_dismiss: "{{ (not v_first_ring) and _fired_recently and (not _looks_snooze) }}"
      _go: "{{ (_ok_first_ring or _ok_final_dismiss) and _cool_ok }}"

      # Initial target speak time (post delay after scheduled alarm time)
      _speak_at_ts: "{{ (_prev_ts + (_post_delay_s | int)) if (_ok_first_ring or _ok_final_dismiss) else _now_ts }}"

  - condition: template
    value_template: "{{ _go }}"

  # --- Optional wait: hold for a real DISMISS (Companion 'Last Removed Notification') ---
  - choose:
      - conditions: "{{ _dismiss_sensor | default('') | string != '' }}"
        sequence:
          - wait_for_trigger:
              - platform: state
                entity_id: !input dismiss_sensor
            timeout:
              seconds: "{{ _dismiss_timeout_s }}"
            continue_on_timeout: true

          - variables:
              _dismiss_pkg: >-
                {{ (state_attr(_dismiss_sensor, 'package') 
                     or state_attr(_dismiss_sensor, 'android.appInfo') 
                     or '') | lower }}
              _dismiss_hit: "{{ wait.completed | default(false) }}"
              _dismiss_ok: "{{ _dismiss_hit and (_dismiss_pkg | regex_search(_clock_pkg_pat)) }}"

              # After a removal, check current next alarm on the same sensor that triggered the ring
              _curr_next: "{{ states(trigger.entity_id) if trigger and trigger.entity_id else '' }}"
              _curr_next_ts: "{{ as_timestamp(_curr_next, default=0) }}"
              _now2_ts: "{{ now().timestamp() }}"
              _snooze_now: >-
                {{ _dismiss_ok and (_curr_next_ts > _now2_ts) 
                   and ((_curr_next_ts - _now2_ts) <= ((_snooze_thr_m | int) * 60)) }}

          # If it looks like a snooze, stop and wait for the snoozed ring cycle to retrigger
          - choose:
              - conditions: "{{ _snooze_now }}"
                sequence:
                  - stop: "Alarm snoozed — skipping brief until next ring."

          # Otherwise, it was a true dismiss: speak ~now (+2s buffer)
          - variables:
              _speak_at_ts: >-
                {% if _dismiss_ok %}
                  {{ now().timestamp() + 2 }}
                {% else %}
                  {{ _speak_at_ts }}
                {% endif %}

  # --- Fetch today's events (and optional weather) ---
  - variables:
      start_dt: "{{ today_at('00:00:00') }}"
      end_dt:   "{{ as_datetime(as_timestamp(today_at('00:00:00')) + 86400) }}"

  - service: calendar.get_events
    target:
      entity_id: !input calendars
    data:
      start_date_time: "{{ start_dt }}"
      end_date_time: "{{ end_dt }}"
    response_variable: agenda

  - choose:
      - conditions: "{{ v_include_weather }}"
        sequence:
          - service: weather.get_forecasts
            target:
              entity_id: !input weather_entity
            data:
              type: daily
            response_variable: forecast
          - variables:
              weather_key: !input weather_entity
              today_forecast: >-
                {% set key = weather_key %}
                {% if forecast and forecast is mapping and (key in forecast)
                      and ('forecast' in forecast[key]) and (forecast[key]['forecast'] | count) > 0 %}
                  {{ forecast[key]['forecast'][0] }}
                {% else %}{}{% endif %}
    default:
      - variables:
          today_forecast: {}

  # --- Flatten + @mention filter (case-insensitive), HA Jinja-safe ---
  - variables:
      v_person_lc: "{{ (v_person | lower | trim) }}"
      events_flat: >-
        {% set ns = namespace(items=[]) %}
        {% for cal in agenda %}
          {% set payload = agenda[cal] %}
          {% if payload is mapping and 'events' in payload %}
            {% for e in payload['events'] %}
              {% set summary = (e['summary'] if 'summary' in e else '') %}
              {% set s = summary | lower %}
              {% set has_any_tag = (s | regex_search('@[\\w-]+')) if (v_excl_others) else false %}
              {% set tagged_me = (v_excl_others and (v_person_lc|length > 0)
                                   and (s | regex_search('(^|\\W)@' ~ v_person_lc ~ '(\\W|$)'))) %}
              {% set tagged_all = (v_excl_others and (s | regex_search('(^|\\W)@all(\\W|$)'))) %}
              {% set include = (not v_excl_others) or tagged_me or tagged_all or (not has_any_tag) %}
              {% if include %}
                {% set start = e['start'] %}
                {% set all_day = (start is string and start|length == 10) %}
                {% set sort_key = (start ~ 'T00:00:00') if all_day else start %}
                {% set ns.items = ns.items + [ {
                  'calendar': cal,
                  'summary': summary,
                  'start': start,
                  'end': e['end'],
                  'all_day': all_day,
                  'sort_key': sort_key
                } ] %}
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        {{ (ns.items | sort(attribute='sort_key'))[: (v_max_events | int) ] }}

  # --- De-duplicate events by (lowercased summary + start time) ---
  - variables:
      events_dedup: >-
        {% set ns = namespace(items=[], seen=[]) %}
        {% for e in events_flat %}
          {% set key = (e.summary | lower | trim) ~ '|' ~ (e.start | string) %}
          {% if key not in ns.seen %}
            {% set ns.seen = ns.seen + [key] %}
            {% set ns.items = ns.items + [e] %}
          {% endif %}
        {% endfor %}
        {{ ns.items }}

  # --- LLM prompt + retries (delay is AFTER this so we don't double-wait) ---
  - variables:
      llm_prompt: >-
        You are generating a short morning briefing to be spoken by Alexa{% if v_person|trim %} to {{ v_person }}{% endif %}.
        Use British date/time conventions.
        {% if v_extra|trim %}Additional instructions: {{ v_extra }}{% endif %}
        Input data is JSON:
        {
          "date_iso": "{{ now().date().isoformat() }}",
          "events": {{ events_dedup | tojson }},
          "weather_today": {{ today_forecast | tojson }}
        }
        Rules:
        - Start with weekday and date{{ ' and a one-line weather headline (temp highs/lows; mention rain chance if present)' if v_include_weather else '' }}.
        - If weather_today is empty, omit the weather entirely.
        - List key events in chronological order with clear times (e.g., "at 08:30, GCSE Physics revision; at 11:00, dentist").
        - If multiple entries describe the same event (same time and similar title), mention it once (deduplicate).
        - For all-day events just say "(all day)".
        - If there are no events, say that explicitly and give a brief encouragement.
        - Keep to about 3–6 short sentences. No markup; plain text only.
        - If no name is provided, do not address the listener by name.

  - variables:
      speech_final: ""

  - repeat:
      until:
        - condition: template
          value_template: >-
            {{ (repeat.index >= (v_max_tries | int)) or ((speech_final | default('') | trim) != '') }}
      sequence:
        - service: conversation.process
          data:
            agent_id: !input openai_agent
            text: "{{ llm_prompt }}"
          response_variable: llm

        - variables:
            speech_try: >-
              {{ llm.response.speech.plain.speech
                 if llm is defined and llm.response is defined
                 and llm.response.speech is defined and llm.response.speech.plain is defined
                 else '' }}

        - choose:
            - conditions: "{{ speech_try | trim != '' }}"
              sequence:
                - variables:
                    speech_final: "{{ speech_try }}"
            - conditions: "{{ speech_try | trim == '' }}"
              sequence:
                - delay:
                    milliseconds: >-
                      {{ (v_base_delay_ms | int) * (2 ** (repeat.index - 1)) }}

  # --- Fallback text ---
  - variables:
      speech_basic: >-
        {% set parts = [] %}
        {% set greeting = 'Morning' ~ ( ' ' ~ v_person if v_person|trim else '' ) ~ '.' %}
        {% if v_include_weather and today_forecast %}
          {% set cond = today_forecast.condition | default('') %}
          {% set hi = today_forecast.temperature | default('?') %}
          {% set lo = today_forecast.templow | default('?') %}
          {% set parts = parts + [ greeting ~ ' Today: ' ~ cond ~ ', high ' ~ hi ~ '°, low ' ~ lo ~ '°.' ] %}
        {% else %}
          {% set parts = parts + [ greeting ] %}
        {% endif %}
        {% if events_dedup | count == 0 %}
          {% set parts = parts + ['No events in the calendar. Have a great day!'] %}
        {% else %}
          {% set parts = parts + ['Here are your events:'] %}
          {% for e in events_dedup %}
            {% if e.all_day %}
              {% set line = e.summary ~ ' (all day)' %}
            {% else %}
              {% set line = (e.start[11:16]) ~ ': ' ~ e.summary %}
            {% endif %}
            {% set parts = parts + [line] %}
          {% endfor %}
        {% endif %}
        {{ (parts | join(' '))[:790] }}

      speech: "{{ (speech_final | default('') | trim) if (speech_final | default('') | trim) != '' else speech_basic }}"

  # --- Final snooze guard (works even without dismiss sensor) ---
  - variables:
      _min_next_delta: >-
        {% set deltas = [] %}
        {% for s in _sensors %}
          {% set state = states(s) %}
          {% set ts = as_timestamp(state, default=0) %}
          {% if ts > 0 %}
            {% set deltas = deltas + [ ts - now().timestamp() ] %}
          {% endif %}
        {% endfor %}
        {{ (deltas | min) if (deltas | count) > 0 else 999999 }}

  - condition: template
    value_template: >-
      {{ not (_min_next_delta > 0 and _min_next_delta <= ((_snooze_thr_m | int) * 60)) }}

  # --- Delay until intended speak time (remaining time only), then speak on Alexa ---
  - variables:
      _delay_left_s: "{{ max(0, (_speak_at_ts - now().timestamp()) | int) }}"
  - choose:
      - conditions: "{{ _delay_left_s > 0 }}"
        sequence:
          - delay:
              seconds: "{{ _delay_left_s }}"

  - service: notify.alexa_media
    data:
      target: !input alexa_targets
      message: "{{ speech[:790] }}"
      data:
        type: "{{ v_tts_mode }}"
