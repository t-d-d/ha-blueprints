# v12.6 — Speak-gap fallback hold (no helper required)
# - If `speak_gap_minutes > 0` **and** no `last_spoke_helper` is set, we now hold the
#   automation for the duration of the gap **after speaking**. Because `mode: single`
#   and `max_exceeded: silent`, triggers that occur during this hold are ignored —
#   effectively enforcing a speak gap without a helper.
# - If you DO provide `last_spoke_helper` (recommended for long gaps), we enforce
#   the gap via the timestamp check (more resilient across reboots and avoids holding
#   the automation task for a long time).
# - Removed the notification about a missing helper; the blueprint “just works”.
# - All other fixes from v12.5 retained (ring-window guard, template manual trigger,
#   dedupe fix, templated optional targets, minimal LLM JSON + **IMPORTANT** tail).

blueprint:
  name: My Daily Briefing — Alarm Calendar & Weather (Echo + Any TTS)
  description: >
    Speaks today’s calendar (optional weather & LLM) when your phone/Echo alarm fires — or when you flip the
    optional manual trigger ON. The ring-window guard avoids firing when you only set/edit alarms. After a short
    post-ring delay, it checks for snoozes and announces via Alexa or any TTS. Supports @mentions (e.g., @Ana, @all).

    Speak gap: If you set a gap but don't select the helper, we will hold the automation at the end for that gap
    (mode: single drops overlapping triggers). For long gaps, using the input_datetime helper is better.
  domain: automation

  input:
    # --- Core (simple) ---
    alarm_sensors:
      name: Next-alarm sensors
      description: "Choose timestamp sensors like sensor.*_next_alarm from phones/Echos."
      selector:
        entity:
          multiple: true
          filter:
            - domain: sensor
              device_class: timestamp
              integration: mobile_app
            - domain: sensor
              device_class: timestamp
              integration: alexa_media

    manual_trigger:
      name: Manual trigger (helper; optional)
      description: >
        An input_boolean you can toggle ON to trigger a briefing (for testing or non‑integrated alarms).
        It will be turned OFF automatically at start.
      default: ""
      selector:
        entity:
          domain: input_boolean

    # Snooze handling
    snooze_window_minutes:
      name: Snooze/stacked-alarm window (minutes)
      description: >
        After the post-ring delay, if the next alarm across your selected sensors is within this many minutes,
        treat it as a snooze/stacked alarm and **skip** speaking (the next ring will retrigger).
        Set to **0** to always speak on every ring (ignore snoozes).
      default: 0
      selector:
        number:
          min: 0
          max: 30
          step: 1
          mode: slider

    # Speak spacing (friendly wording)
    speak_gap_minutes:
      name: Speak gap (minutes)
      description: >
        Minimum gap between briefings. If the last time we actually spoke is within this many minutes,
        we skip this run (when a helper is set). If no helper is set, we'll hold the automation after
        speaking for this duration so overlap triggers are dropped.
      default: 0
      selector:
        number:
          min: 0
          max: 120
          step: 1
          mode: slider

    last_spoke_helper:
      name: Last spoken time (input_datetime; optional)
      description: >
        Recommended for long gaps. We update it to now() when a briefing is spoken, and skip new runs until
        the gap has elapsed. If left empty, we enforce the gap by holding the automation after speaking.
      default: ""
      selector:
        entity:
          domain: input_datetime

    # One combined targets list — Echo + other media players
    speak_targets:
      name: Speakers (any)
      description: "Pick any media_player(s): Echo, Sonos, Nest, Chromecast, etc."
      selector:
        entity:
          domain: media_player
          multiple: true

    # Optional engine for non-Alexa targets (Piper, Google Cloud, Polly, etc.)
    tts_engine:
      name: TTS engine for non-Alexa (optional)
      description: "Required only for non-Alexa players. Example: tts.piper"
      default: ""
      selector:
        entity:
          domain: tts

    # --- Volume control ---
    set_volume:
      name: Set speaker volume
      description: "If on, set volume for all selected players before speaking. (Some devices ignore this when idle.)"
      default: false
      selector:
        boolean: {}

    speak_volume:
      name: Speaking volume
      description: "0.00–1.00 (used only if 'Set speaker volume' is on)."
      default: 0.35
      selector:
        number:
          min: 0
          max: 1
          step: 0.05
          mode: slider

    restore_volume:
      name: Restore previous volume after speaking
      default: true
      selector:
        boolean: {}

    calendars:
      name: Calendars to include
      selector:
        entity:
          domain: calendar
          multiple: true

    weather_entity:
      name: Weather entity (optional)
      default: ""
      selector:
        entity:
          domain: weather

    person_name:
      name: Person name (optional; leave blank to omit)
      default: ""
      selector:
        text: {}

    extra_instructions:
      name: Extra instructions (optional)
      description: "Any extra guidance for tone/phrasing. Appended to the prompt as **IMPORTANT:**"
      default: ""
      selector:
        text: {}

    exclude_other_mentions:
      name: Exclude events @'ed to others
      description: "On = include only untagged items, @<your name>, or @all"
      default: true
      selector:
        boolean: {}

    openai_agent:
      name: LLM agent (optional)
      description: "Select your Conversation agent (e.g., conversation.openai). Leave blank to skip LLM and use fallback narration."
      default: ""
      selector:
        entity:
          domain: conversation

    # --- Advanced (optional; safe defaults) ---
    advanced:
      name: Advanced (optional)
      description: >
        Paste YAML/JSON with fields (defaults shown):

        speak_delay_seconds: 30
        ring_window_before_seconds: 5
        ring_window_after_seconds: 120
        tts_mode: "tts"     # Alexa: "tts" or "announce"
        max_events: 12
        retry_attempts: 3
        retry_base_delay_ms: 1200

        Example (YAML):
          speak_delay_seconds: 20
          ring_window_before_seconds: 5
          ring_window_after_seconds: 120
          tts_mode: announce
          max_events: 10
      default: {}
      selector:
        object: {}

mode: single
max_exceeded: silent

trigger_variables:
  manual_trigger_entity: !input manual_trigger

trigger:
  - platform: state
    entity_id: !input alarm_sensors

  # Optional manual toggle via template trigger. Safe when empty (never true).
  - platform: template
    value_template: >-
      {% set ent = manual_trigger_entity | string %}
      {{ ent != '' and is_state(ent, 'on') }}

variables:
  person_name: !input person_name
  extra_instructions: !input extra_instructions
  exclude_other_mentions: !input exclude_other_mentions
  snooze_window_minutes: !input snooze_window_minutes
  speak_gap_minutes: !input speak_gap_minutes
  last_spoke_entity: !input last_spoke_helper
  manual_trigger_entity: !input manual_trigger
  did_speak: false

action:
  # --- START: always clear the manual trigger if present so it doesn't stick ON ---
  - choose:
      - conditions: "{{ manual_trigger_entity | string != '' and is_state(manual_trigger_entity, 'on') }}"
        sequence:
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ manual_trigger_entity }}"

  # --- Variables & guards ---
  - variables:
      adv: !input advanced
      alarm_entities: !input alarm_sensors
      agent_entity: !input openai_agent
      weather_key: !input weather_entity

      # Volume inputs
      set_volume: !input set_volume
      speak_volume: !input speak_volume
      restore_volume: !input restore_volume

      speak_delay_seconds: "{{ adv.speak_delay_seconds | default(30) }}"
      ring_window_before_seconds: "{{ adv.ring_window_before_seconds | default(5) }}"
      ring_window_after_seconds:  "{{ adv.ring_window_after_seconds  | default(120) }}"
      tts_mode: "{{ adv.tts_mode | default('tts') }}"
      max_events: "{{ adv.max_events | default(12) }}"
      retry_attempts: "{{ adv.retry_attempts | default(3) }}"
      retry_base_delay_ms: "{{ adv.retry_base_delay_ms | default(1200) }}"

      # Trigger context
      is_from_alarm_sensor: "{{ trigger.platform == 'state' and (trigger.entity_id in alarm_entities) }}"
      alarm_prev_iso: "{{ trigger.from_state.state if trigger.from_state else '' }}"
      prev_alarm_ts: "{{ as_timestamp(alarm_prev_iso, default=0) }}"
      now_ts: "{{ now().timestamp() }}"
      in_ring_window: >-
        {{ is_from_alarm_sensor and (now_ts >= (prev_alarm_ts - (ring_window_before_seconds | int)))
           and (now_ts <= (prev_alarm_ts + (ring_window_after_seconds | int))) }}

  # --- Ring window gate: only run if alarm actually fired (ignore when just scheduling) ---
  - condition: template
    value_template: "{{ (not is_from_alarm_sensor) or in_ring_window }}"

  # --- Post-ring delay (lets snooze/next-alarm update; also dedupes overlaps via mode: single) ---
  - delay:
      seconds: "{{ speak_delay_seconds }}"

  # --- Snooze/second-alarm guard: check CURRENT next alarms after the delay ---
  - variables:
      min_next_alarm_delta: >-
        {% set ns = namespace(deltas=[]) %}
        {% for s in alarm_entities %}
          {% set state = states(s) %}
          {% set ts = as_timestamp(state, default=0) %}
          {% if ts > 0 %}
            {% set ns.deltas = ns.deltas + [ ts - now().timestamp() ] %}
          {% endif %}
        {% endfor %}
        {{ (ns.deltas | min) if (ns.deltas | count) > 0 else 999999 }}

  - condition: template
    value_template: >-
      {{ not ( (snooze_window_minutes | int) > 0 and (min_next_alarm_delta > 0) and (min_next_alarm_delta <= ((snooze_window_minutes | int) * 60)) ) }}

  # --- Speak gap guard (cooldown between SPOKEN briefings) — helper path ---
  - variables:
      last_spoke_ts: >-
        {% if (last_spoke_entity | string) != '' %}
          {{ as_timestamp(states(last_spoke_entity), default=0) }}
        {% else %}0{% endif %}
      helper_present: "{{ (last_spoke_entity | string) != '' }}"
      speak_gap_ok: >-
        {% set gap = (speak_gap_minutes | int) * 60 %}
        {% if gap == 0 %}
          true
        {% elif not helper_present %}
          true
        {% else %}
          {{ (now().timestamp() - (last_spoke_ts | float(0))) > gap }}
        {% endif %}

  - condition: template
    value_template: "{{ speak_gap_ok }}"

  # --- Fetch today's events (and optional weather) ---
  - variables:
      start_dt: "{{ today_at('00:00:00') }}"
      end_dt:   "{{ as_datetime(as_timestamp(today_at('00:00:00')) + 86400) }}"

  - service: calendar.get_events
    target:
      entity_id: !input calendars
    data:
      start_date_time: "{{ start_dt }}"
      end_date_time: "{{ end_dt }}"
    response_variable: agenda

  - choose:
      - conditions: "{{ weather_key | string != '' }}"
        sequence:
          - service: weather.get_forecasts
            target:
              entity_id: "{{ weather_key }}"
            data:
              type: daily
            response_variable: forecast
          - variables:
              today_forecast: >-
                {% set key = weather_key %}
                {% if forecast and forecast is mapping and (key in forecast)
                      and ('forecast' in forecast[key]) and (forecast[key]['forecast'] | count) > 0 %}
                  {{ forecast[key]['forecast'][0] }}
                {% else %}{}{% endif %}
    default:
      - variables:
          today_forecast: {}

  # --- Flatten + @mention filter; robust date_only; compute local times for today ---
  - variables:
      person_lc: "{{ (person_name | lower | trim) }}"
      events_flat: >-
        {% set ns = namespace(raw=[], out=[]) %}
        {% for cal in agenda %}
          {% set payload = agenda[cal] %}
          {% if payload is mapping and 'events' in payload %}
            {% for e in payload['events'] %}
              {% set summary = (e['summary'] if 'summary' in e else '') %}
              {% set s = summary | lower %}
              {% set has_any_tag = (s | regex_search('@[\w-]+')) if (exclude_other_mentions) else false %}
              {% set tagged_me = (exclude_other_mentions and (person_lc|length > 0)
                                   and (s | regex_search('(^|\W)@' ~ person_lc ~ '(\W|$)'))) %}
              {% set tagged_all = (exclude_other_mentions and (s | regex_search('(^|\W)@all(\W|$)'))) %}
              {% set include = (not exclude_other_mentions) or tagged_me or tagged_all or (not has_any_tag) %}
              {% if include %}
                {% set start_s = (e['start'] | string) %}
                {% set end_s   = (e['end']   | string) %}
                {% set start_dt = as_datetime(start_s, default=None) %}
                {% set end_dt   = as_datetime(end_s,   default=None) %}
                {% set date_only = ('T' not in start_s) or (start_dt and end_dt and
                    start_dt.hour == 0 and start_dt.minute == 0 and start_dt.second == 0 and
                    (end_dt - start_dt).total_seconds() >= 23*3600) %}
                {% set start_loc = as_local(start_dt) if start_dt else None %}
                {% set end_loc   = as_local(end_dt)   if end_dt   else None %}
                {% set today_date = now().date() %}
                {% set start_is_today = (start_loc and (start_loc.date() == today_date)) %}
                {% set end_is_today   = (end_loc   and (end_loc.date()   == today_date)) %}
                {% set local_start_time = '' if (date_only or not start_is_today) else start_loc.strftime('%H:%M') %}
                {% set local_end_time   = '' if (date_only or not end_is_today)   else end_loc.strftime('%H:%M') %}
                {% set sort_key = (
                    start_loc if (start_is_today and not date_only) else
                    end_loc   if (end_is_today   and not date_only) else
                    as_local(as_datetime(today_at('00:00:00'))) ) %}
                {% set ns.raw = ns.raw + [ {
                  'summary': summary,
                  'local_start_time': local_start_time,
                  'local_end_time': local_end_time,
                  'sort_key': sort_key
                } ] %}
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        {# Now sort by the datetime-only sort_key, but OUTPUT items **without** sort_key (strings only) #}
        {% for e in (ns.raw | sort(attribute='sort_key'))[: (max_events | int) ] %}
          {% set ns.out = ns.out + [ {
            'summary': e['summary'],
            'local_start_time': e['local_start_time'],
            'local_end_time': e['local_end_time']
          } ] %}
        {% endfor %}
        {{ ns.out }}

  - variables:
      events_dedup: >-
        {% set ns = namespace(items=[], seen=[]) %}
        {% for e in events_flat %}
          {% set key = (e['summary'] | default('') | lower | trim) ~ '|' ~ (e['local_start_time'] | default('') | string) ~ '|' ~ (e['local_end_time'] | default('') | string) %}
          {% if key not in ns.seen %}
            {% set ns.seen = ns.seen + [key] %}
            {% set ns.items = ns.items + [e] %}
          {% endif %}
        {% endfor %}
        {{ ns.items }}

  # --- Build minimal events payload for the LLM (summary + local times only) ---
  - variables:
      events_for_llm: >-
        {% set ns = namespace(list=[]) %}
        {% for e in events_dedup %}
          {% set ns.list = ns.list + [ {
            'summary': e['summary'],
            'local_start_time': e['local_start_time'],
            'local_end_time': e['local_end_time']
          } ] %}
        {% endfor %}
        {{ ns.list }}

  # --- LLM prompt (minimal guidance) ---
  - variables:
      llm_prompt: >-
        Create a concise morning briefing in British date/time. Use the JSON below.
        - Mention weather if provided.
        - List today’s events in a natural order. If a time string is present (HH:MM) for the start or end, include it.
        Keep it plain and brief (about 3–6 sentences).
        Input JSON:
        {
          "date_iso": "{{ now().date().isoformat() }}",
          "events": {{ events_for_llm | tojson }},
          "weather_today": {{ today_forecast | tojson }}
        }
        {% if extra_instructions | trim %}
        **IMPORTANT**: {{ extra_instructions }}
        {% endif %}
      speech_final: ""

  # --- Run LLM (if selected) ---
  - choose:
      - conditions: "{{ (agent_entity | string) != '' }}"
        sequence:
          - repeat:
              until:
                - condition: template
                  value_template: "{{ (repeat.index >= (retry_attempts | int)) or ((speech_final | default('') | trim) != '') }}"
              sequence:
                - service: conversation.process
                  data:
                    agent_id: "{{ agent_entity }}"
                    text: "{{ llm_prompt }}"
                  response_variable: llm
                - variables:
                    speech_try: >-
                      {{ llm.response.speech.plain.speech
                         if llm and llm.response and llm.response.speech and llm.response.speech.plain
                         else '' }}
                - choose:
                    - conditions: "{{ speech_try | trim != '' }}"
                      sequence:
                        - variables:
                            speech_final: "{{ speech_try }}"
                    - conditions: "{{ speech_try | trim == '' }}"
                      sequence:
                        - delay:
                            milliseconds: "{{ (retry_base_delay_ms | int) * (2 ** (repeat.index - 1)) }}"
    default: []

  # --- Fallback narrator (mirrors the same minimal rules) ---
  - variables:
      final_speech_fallback: >-
        {% set ns = namespace(parts=[]) %}
        {% set greeting = 'Morning' ~ ( ' ' ~ person_name if person_name|trim else '' ) ~ '.' %}
        {% if today_forecast %}
          {% set cond = today_forecast.condition | default('') %}
          {% set hi = today_forecast.temperature | default('?') %}
          {% set lo = today_forecast.templow | default('?') %}
          {% set ns.parts = ns.parts + [ greeting ~ ' Today: ' ~ cond ~ ', high ' ~ hi ~ '°, low ' ~ lo ~ '°.' ] %}
        {% else %}
          {% set ns.parts = ns.parts + [ greeting ] %}
        {% endif %}
        {% if events_dedup | count == 0 %}
          {% set ns.parts = ns.parts + ['No events in the calendar. Have a great day!'] %}
        {% else %}
          {% set ns.parts = ns.parts + ['Here are your events:'] %}
          {% for e in events_dedup %}
            {% if e.local_start_time %}
              {% set line = e.local_start_time ~ ': ' ~ e.summary %}
            {% elif e.local_end_time %}
              {% set line = 'ends ' ~ e.local_end_time ~ ': ' ~ e.summary %}
            {% else %}
              {% set line = e.summary %}
            {% endif %}
            {% set ns.parts = ns.parts + [line] %}
          {% endfor %}
        {% endif %}
        {{ (ns.parts | join(' '))[:790] }}
      speech: >-
        {% set s = (speech_final | default('') | trim) if (speech_final | default('') | trim) != '' else final_speech_fallback %}
        {{ s[:790] }}

  # --- Split speak_targets into Alexa vs non-Alexa (robust + namespace) ---
  - variables:
      all_targets: !input speak_targets
      alexa_all: "{{ integration_entities('alexa_media') | select('match', '^media_player\\.') | list }}"
      alexa_targets: >-
        {% set ns = namespace(items=[]) %}
        {% for e in all_targets %}
          {% if alexa_all is iterable and (e in alexa_all) %}
            {% set ns.items = ns.items + [e] %}
          {% endif %}
        {% endfor %}
        {{ ns.items }}
      generic_targets: >-
        {% set ns = namespace(items=[]) %}
        {% for e in all_targets %}
          {% if not (alexa_all is iterable and (e in alexa_all)) %}
            {% set ns.items = ns.items + [e] %}
          {% endif %}
        {% endfor %}
        {{ ns.items }}
      tts_engine_entity: !input tts_engine

  # --- Preflight validation & user feedback ---
  - variables:
      alexa_integration_present: "{{ (alexa_all | count) > 0 }}"
      alexa_count: "{{ alexa_targets | count }}"
      generic_count: "{{ generic_targets | count }}"
      tts_engine_ok: "{{ tts_engine_entity | string != '' }}"

  - choose:
      - conditions: "{{ alexa_count > 0 and not alexa_integration_present }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "Daily Briefing: Alexa TTS unavailable"
              message: >-
                You selected Alexa devices ({{ alexa_targets | join(', ') }}), but the Alexa Media
                integration wasn't detected. Install/enable it or remove those targets.

  - choose:
      - conditions: "{{ generic_count > 0 and not tts_engine_ok }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "Daily Briefing: No TTS engine for non-Alexa"
              message: >-
                You selected non-Alexa players ({{ generic_targets | join(', ') }}), but no TTS engine
                was set. Choose a TTS entity (e.g., tts.piper) in the automation.

  - choose:
      - conditions: >-
          {{ not (
              (alexa_count > 0 and alexa_integration_present)
              or
              (generic_count > 0 and tts_engine_ok)
            ) }}
        sequence:
          - service: persistent_notification.create
            data:
              title: "Daily Briefing: No usable speakers"
              message: >-
                None of the selected speakers can be used. Fix Alexa Media for Echo or set a TTS engine
                for non-Alexa players.
          - stop: "No usable speakers (see notification)."

  # --- Capture current volumes & set speaking volume (if enabled) ---
  - variables:
      usable_targets: >-
        {% set ns = namespace(items=[]) %}
        {% if alexa_integration_present %}
          {% for e in alexa_targets %}
            {% set ns.items = ns.items + [e] %}
          {% endfor %}
        {% endif %}
        {% if tts_engine_ok %}
          {% for e in generic_targets %}
            {% set ns.items = ns.items + [e] %}
          {% endfor %}
        {% endif %}
        {{ ns.items }}
      prev_volumes: []

  - choose:
      - conditions: "{{ set_volume and (usable_targets | count) > 0 }}"
        sequence:
          - variables:
              prev_volumes: >-
                {% set ns = namespace(items=[]) %}
                {% for e in usable_targets %}
                  {% set v = state_attr(e, 'volume_level') %}
                  {% if v is number %}
                    {% set ns.items = ns.items + [ {'entity': e, 'level': v} ] %}
                  {% endif %}
                {% endfor %}
                {{ ns.items }}
          - repeat:
              for_each: "{{ usable_targets }}"
              sequence:
                - service: media_player.volume_set
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    volume_level: "{{ speak_volume }}"

  # --- Speak on Alexa (alexa_media) ---
  - choose:
      - conditions: "{{ (alexa_count > 0) and alexa_integration_present }}"
        sequence:
          - variables:
              did_speak: true
          - service: notify.alexa_media
            data:
              target: "{{ alexa_targets }}"
              message: "{{ speech }}"
              data:
                type: "{{ tts_mode }}"
    default: []

  # --- Speak on non-Alexa (generic TTS engine) ---
  - choose:
      - conditions: "{{ tts_engine_ok and (generic_count > 0) }}"
        sequence:
          - variables:
              did_speak: true
          - repeat:
              for_each: "{{ generic_targets }}"
              sequence:
                - service: tts.speak
                  target:
                    entity_id: "{{ tts_engine_entity }}"
                  data:
                    media_player_entity_id: "{{ repeat.item }}"
                    message: "{{ speech }}"
    default: []

  # --- Persist last SPOKEN time (helper path)
  - choose:
      - conditions: "{{ did_speak and (last_spoke_entity | string) != '' }}"
        sequence:
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ last_spoke_entity }}"
            data:
              date: "{{ now().date().isoformat() }}"
              time: "{{ now().strftime('%H:%M:%S') }}"
    default: []

  # --- Restore previous volumes (if captured) ---
  - choose:
      - conditions: "{{ set_volume and restore_volume and (prev_volumes | count) > 0 }}"
        sequence:
          - repeat:
              for_each: "{{ prev_volumes }}"
              sequence:
                - service: media_player.volume_set
                  target:
                    entity_id: "{{ repeat.item.entity }}"
                  data:
                    volume_level: "{{ repeat.item.level }}"
    default: []

  # --- Speak-gap fallback hold (no helper) — only when we actually spoke ---
  - choose:
      - conditions: "{{ did_speak and (last_spoke_entity | string) == '' and (speak_gap_minutes | int) > 0 }}"
        sequence:
          - delay:
              seconds: "{{ (speak_gap_minutes | int) * 60 }}"
